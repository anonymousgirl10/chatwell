{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable;})),t.push.apply(t,o);}return t;}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));});}return e;}var TextExtraction=function(){function TextExtraction(text,patterns){_classCallCheck(this,TextExtraction);this.text=text;this.patterns=patterns||[];}_createClass(TextExtraction,[{key:\"parse\",value:function parse(){var _this=this;var parsedTexts=[{children:this.text}];this.patterns.forEach(function(pattern){var newParts=[];var tmp=pattern.nonExhaustiveModeMaxMatchCount||0;var numberOfMatchesPermitted=Math.min(Math.max(Number.isInteger(tmp)?tmp:0,0)||Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY);var currentMatches=0;parsedTexts.forEach(function(parsedText){if(parsedText._matched){newParts.push(parsedText);return;}var parts=[];var textLeft=parsedText.children;var indexOfMatchedString=0;var matches;pattern.pattern.lastIndex=0;while(textLeft&&(matches=pattern.pattern.exec(textLeft))){var previousText=textLeft.substr(0,matches.index);indexOfMatchedString=matches.index;if(++currentMatches>numberOfMatchesPermitted){break;}parts.push({children:previousText});parts.push(_this.getMatchedPart(pattern,matches[0],matches,indexOfMatchedString));textLeft=textLeft.substr(matches.index+matches[0].length);indexOfMatchedString+=matches[0].length-1;pattern.pattern.lastIndex=0;}parts.push({children:textLeft});newParts.push.apply(newParts,parts);});parsedTexts=newParts;});parsedTexts.forEach(function(parsedText){return delete parsedText._matched;});return parsedTexts.filter(function(t){return!!t.children;});}},{key:\"getMatchedPart\",value:function getMatchedPart(matchedPattern,text,matches,index){var props={};Object.keys(matchedPattern).forEach(function(key){if(key==='pattern'||key==='renderText'||key==='nonExhaustiveModeMaxMatchCount'){return;}if(typeof matchedPattern[key]==='function'){props[key]=function(){return matchedPattern[key](text,index);};}else{props[key]=matchedPattern[key];}});var children=text;if(matchedPattern.renderText&&typeof matchedPattern.renderText==='function'){children=matchedPattern.renderText(text,matches);}return _objectSpread(_objectSpread({},props),{},{children:children,_matched:true});}}]);return TextExtraction;}();export default TextExtraction;","map":{"version":3,"names":["TextExtraction","text","patterns","_classCallCheck","_createClass","key","value","parse","_this","parsedTexts","children","forEach","pattern","newParts","tmp","nonExhaustiveModeMaxMatchCount","numberOfMatchesPermitted","Math","min","max","Number","isInteger","POSITIVE_INFINITY","currentMatches","parsedText","_matched","push","parts","textLeft","indexOfMatchedString","matches","lastIndex","exec","previousText","substr","index","getMatchedPart","length","apply","filter","t","matchedPattern","props","Object","keys","renderText","_objectSpread"],"sources":["/home/whm/Documents/WHM/app/chatwell/chatwell/node_modules/react-native-parsed-text/src/lib/TextExtraction.js"],"sourcesContent":["/**\n * If you want to provide a custom regexp, this is the configuration to use.\n * -- For historical reasons, all regexps are processed as if they have the global flag set.\n * -- Use the nonExhaustiveModeMaxMatchCount property to match a limited number of matches.\n * Note: any additional keys/props are permitted, and will be returned as-is!\n * @typedef {Object} CustomParseShape\n * @property {RegExp} pattern\n * @property {number} [nonExhaustiveModeMaxMatchCount] Enables \"non-exhaustive mode\", where you can limit how many matches are found. -- Must be a positive integer or Infinity matches are permitted\n * @property {Function} [renderText] arbitrary function to rewrite the matched string into something else\n * @property {Function} [onPress]\n * @property {Function} [onLongPress]\n */\n/**\n * Class to encapsulate the business logic of converting text into matches & props\n */\nclass TextExtraction {\n  /**\n   * @param {String} text - Text to be parsed\n   * @param {CustomParseShape[]} patterns - Patterns to be used when parsed,\n   *                                 any extra attributes, will be returned from parse()\n   */\n  constructor(text, patterns) {\n    this.text = text;\n    this.patterns = patterns || [];\n  }\n\n  /**\n   * Returns parts of the text with their own props\n   * @public\n   * @return {Object[]} - props for all the parts of the text\n   */\n  parse() {\n    let parsedTexts = [{ children: this.text }];\n    this.patterns.forEach((pattern) => {\n      let newParts = [];\n\n      const tmp = pattern.nonExhaustiveModeMaxMatchCount || 0;\n      const numberOfMatchesPermitted = Math.min(\n        Math.max(Number.isInteger(tmp) ? tmp : 0, 0) ||\n          Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY,\n      );\n\n      let currentMatches = 0;\n\n      parsedTexts.forEach((parsedText) => {\n        // Only allow for now one parsing\n        if (parsedText._matched) {\n          newParts.push(parsedText);\n          return;\n        }\n\n        let parts = [];\n        let textLeft = parsedText.children;\n        let indexOfMatchedString = 0;\n\n        /** @type {RegExpExecArray} */\n        let matches;\n        // Global RegExps are stateful, this makes it start at 0 if reused\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec\n        pattern.pattern.lastIndex = 0;\n        while (textLeft && (matches = pattern.pattern.exec(textLeft))) {\n          let previousText = textLeft.substr(0, matches.index);\n          indexOfMatchedString = matches.index;\n\n          if (++currentMatches > numberOfMatchesPermitted) {\n            // Abort if we've exhausted our number of matches\n            break;\n          }\n\n          parts.push({ children: previousText });\n\n          parts.push(\n            this.getMatchedPart(\n              pattern,\n              matches[0],\n              matches,\n              indexOfMatchedString,\n            ),\n          );\n\n          textLeft = textLeft.substr(matches.index + matches[0].length);\n          indexOfMatchedString += matches[0].length - 1;\n          // Global RegExps are stateful, this makes it operate on the \"remainder\" of the string\n          pattern.pattern.lastIndex = 0;\n        }\n\n        parts.push({ children: textLeft });\n\n        newParts.push(...parts);\n      });\n\n      parsedTexts = newParts;\n    });\n\n    // Remove _matched key.\n    parsedTexts.forEach((parsedText) => delete parsedText._matched);\n\n    return parsedTexts.filter((t) => !!t.children);\n  }\n\n  // private\n\n  /**\n   * @protected\n   * @param {ParseShape} matchedPattern - pattern configuration of the pattern used to match the text\n   * @param {String} text - Text matching the pattern\n   * @param {String[]} matches - Result of the RegExp.exec\n   * @param {Integer} index - Index of the matched string in the whole string\n   * @return {Object} props for the matched text\n   */\n  getMatchedPart(matchedPattern, text, matches, index) {\n    let props = {};\n\n    Object.keys(matchedPattern).forEach((key) => {\n      if (\n        key === 'pattern' ||\n        key === 'renderText' ||\n        key === 'nonExhaustiveModeMaxMatchCount'\n      ) {\n        return;\n      }\n\n      if (typeof matchedPattern[key] === 'function') {\n        // Support onPress / onLongPress functions\n        props[key] = () => matchedPattern[key](text, index);\n      } else {\n        // Set a prop with an arbitrary name to the value in the match-config\n        props[key] = matchedPattern[key];\n      }\n    });\n\n    let children = text;\n    if (\n      matchedPattern.renderText &&\n      typeof matchedPattern.renderText === 'function'\n    ) {\n      children = matchedPattern.renderText(text, matches);\n    }\n\n    return {\n      ...props,\n      children: children,\n      _matched: true,\n    };\n  }\n}\n\nexport default TextExtraction;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}